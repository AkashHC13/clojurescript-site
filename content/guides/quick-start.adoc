= Quick Start
David Nolen
2016-07-29
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

[[quick-start-toc]]
toc::[]

If you are using OS X or Linux the only dependencies required for this tutorial
are an installation of https://clojure.org/guides/getting_started[Clojure]. On
Windows you will need
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[Java
8] and the
https://github.com/clojure/clojurescript/releases/download/r1.9.473/cljs.jar[standalone
ClojureScript JAR].

[[clojurescript-compiler]]
=== ClojureScript Compiler

Create a directory `hello_world` then from _inside_ the `hello_world` directory:

[source,bash]
----
mkdir -p src/hello_world;touch src/hello_world/core.cljs
----

For Windows:

[source,bash]
----
md src\hello_world & type nul >>core.cljs & move core.cljs src\hello_world
----

If you're on Linux or OS X create a `deps.edn` file with the following contents:

[source,clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.104"}}}
----

If you're on Windows simply copy `cljs.jar` into this directory.

Then in your favorite text editor edit the `src/hello_world/core.cljs` to
look like the following:

[source,clojure]
----
(ns hello-world.core)

(println "Hello world!")
----

First we declare our namespace. Note that if a ClojureScript file declares a
namespace then this namespace must match the path on disk. We then print the
famous message.

Let's build and run some ClojureScript:

[source,bash]
----
clj -m cljs.main -c hello-word.core -r
----

On Windows:

[source,bash]
----
java -cp "cljs.jar;src" -m cljs.main -c hello-word.core -r
----

Your default web browser will open to a page that looks like the following:

After a couple of seconds your terminal should show you a REPL prompt. Your
terminal is now connected to your browser.

[source,clojure]
---
(require 'hello-world.core)
---

You should see `Hello world!` print in your terminal.

Change your `src/hello_world/core.cljs` source file to look like the
following:

[source,clojure]
----
(ns hello-world.core)

(println "Hello world!")

;; ADDED
(defn foo [a b]
  (+ a b))
----

At the REPL prompt, recompile and reload your namespace by evaluating
`(require '[hello-world.core :as hello] :reload)`. Try evaluating
`(hello/foo 2 3)`, you should get the result `5`.

Lets make a mistake. Try evaluating `(ffirst [1])`. You should get a
source mapped stack trace pointing at ClojureScript source locations not
JavaScript ones. This makes debugging a lot nicer.

[[production-builds]]
== Production Builds

You may have noticed that `out` contains a lot of JavaScript.
Fortunately the ClojureScript compiler generates output optimized for
the Google Closure Compiler. The Google Closure Compiler performs many
optimizations, but the most significant for browser-based clients are
minification and dead code elimination.

Let's remove the dev time REPL bits from `src/hello_world/core.cljs`:

[source,clojure]
----
(ns hello-world.core)

(println "Hello world!")
----

Let's create a release build:

[source,clojure]
----
clj -m cljs.main -O advanced -o out/main.js -c hello-world.core
----

This process will take significantly longer which is why we don't use
this compilation mode for development.

Open `index.html`, you should still see `"Hello world!"` printed.

Examine `out/main.js`, the file size should be around 80K. If you zip
this file you'll see that it's around 19K. This is significantly smaller
than a jQuery dependency yet when using ClojureScript you have implicit
dependencies on the entire ClojureScript standard library (10KLOC) and
the Google Closure Library (300KLOC). You can thank dead code
elimination.

[[running-clojurescript-on-node.js]]
== Running ClojureScript on Node.js

First install Node.js. For instructions on installing Node.js, see the
https://github.com/nodejs/node/blob/master/README.md[Node.js wiki]. Only
the current stable versions of Node.js (>= `0.12.X`) are supported at
this time. Your `src/hello_world/core.cljs` should look like the
following:

[source,clojure]
----
(ns hello-world.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

Make a build helper file called `node.clj`:

[source,clojure]
----
(require 'cljs.build.api)

(cljs.build.api/build "src"
  {:main 'hello-world.core
   :output-to "main.js"
   :target :nodejs})
----

The only differences are that we had to specify a `:nodejs` target and
we do not output `main.js` to the `out` directory. This is important due
to the way that Node.js resolves JavaScript source files.

Node.js has great source mapping support, in order to enable it just
install `source-map-support`:

[source,bash]
----
npm install source-map-support
----

Let's build your Node project:

[source,bash]
----
java -cp cljs.jar:src clojure.main node.clj
----

You can run your file with:

[source,bash]
----
node main.js
----

[NOTE]
====
**Note**: Under Node.js there is little reason to use advanced
optimizations. While advanced optimizations does apply performance
related optimizations, these are now largely obviated by optimizations
present in modern JavaScript virtual machines like V8, SpiderMonkey, and
JavaScriptCore. For Node.js, `:simple` or `:none` optimizations suffice
and using them removes the need for extra steps like supplying an
externs file.
====

[[node.js-repl]]
=== Node.js REPL

Running a Node.js REPL is similar to running a browser REPL.
Create a helper build file called `node_repl.clj` that looks like the
following:

[source,clojure]
----
(require 'cljs.repl)
(require 'cljs.build.api)
(require 'cljs.repl.node)

(cljs.build.api/build "src"
  {:main 'hello-world.core
   :output-to "out/main.js"
   :verbose true})

(cljs.repl/repl (cljs.repl.node/repl-env)
  :watch "src"
  :output-dir "out")
----

There's no need to add any REPL specific bits to
`src/hello_world/core.cljs`, make sure it looks as described in the
previous section.

Let's start the REPL:

[source,bash]
----
rlwrap java -cp cljs.jar:src clojure.main node_repl.clj
----

All the previously described REPL interactions for the browser should
work.

[[dependencies]]
== Dependencies

ClojureScript supports a wide variety of options for including
ClojureScript and JavaScript dependencies (see
<<xref/../../../reference/dependencies#,Dependencies>>
for details). However the simplest
approach is to include a properly packaged JAR on the classpath.
http://cljsjs.github.io[CLJSJS] provides a nice set of curated
JavaScript libraries that suffices to demonstrate how dependencies are
handled.

http://facebook.github.io/react/[React] is a popular dependency for
ClojureScript projects. http://cljsjs.github.io[CLJSJS] provides a
https://github.com/cljsjs/packages/tree/master/react[bundled version].
Let's see how to include it.

Grab the JAR from https://clojars.org[Clojars]:

[source,bash]
----
curl -O https://clojars.org/repo/cljsjs/react/15.6.1-0/react-15.6.1-0.jar
----

Let's edit our simple program to look like the following so that React
is properly required:

[source,clojure]
----
(ns hello-world.core
  (:require cljsjs.react))

(enable-console-print!)

(println "Hello React!")
----

Let's rebuild our project, all we need to do is extend our classpath to
include the CLJSJS React JAR.

[source,bash]
----
java -cp cljs.jar:src:react-15.6.1-0.jar clojure.main build.clj
----

If you refresh your `index.html` page you should see the usual React log
indicating that React was successfully loaded.

If you have a few dependencies, one convention is to put them into a
folder called `lib`. Then you can launch your scripts like so:

[source,bash]
----
java -cp 'cljs.jar:lib/*:src' clojure.main build.clj
----

As your dependency graph becomes more sophisticated it may make sense to
rely on Maven or Leiningen to manage dependencies for you. Please refer
to <<xref/../../../reference/dependencies#,Dependencies>> for a comprehensive tutorial. What
follows is just the basics.

[[leiningen]]
=== Leiningen

All the commands above may be executed with the `run` feature of
Leiningen. With Leiningen you do not need to specify the classpath. For
example for a REPL you would do something like the following from your
project directory:

[source,bash]
----
lein run -m clojure.main repl.clj
----

One important thing to remember with Leiningen is the `:source-paths`
configuration parameter. The `:source-paths`, found in the project.clj,
are appended to the classpath. For a ClojureScript build you should
include all the source paths to your ClojureScript sources in the
`:source-paths` parameter. The path "src" is included by default.

This is especially important if you use another path besides "src".

If you have any questions about the classpath you can see it easily by
typing `lein classpath`.

[[maven]]
=== Maven

Same as Leiningen, you can use Maven to run the above scripts and you do
not need to specify the classpath. Add the `clojure-maven-plugin` to
your `pom.xml`:

[source,xml]
----
<project xmlns="..."
         xsi:schemaLocation="....">
    <modelVersion>4.0.0</modelVersion>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>com.theoryinpractise</groupId>
                <artifactId>clojure-maven-plugin</artifactId>
                <version>1.7.1</version>
                <extensions>true</extensions>
            </plugin>
        </plugins>
    </build>
    ...
</project>
----

Then you can start a repl with the `clojure:run` task:

[source,bash]
----
mvn clojure:run -Dclojure.script=repl.clj
----
