= JavaScript Modules (Alpha)
David Nolen
2017-01-22
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

This page documents how to mix modern JavaScript source files seamlessly into
an existing ClojureScript project. The features documented should be considered
of alpha quality and subject to change.

[[motivation]]
== Motivation

When ClojureScript was initially released, compilation to JavaScript was still a
novelty and source transformation beyond minification was rare. More recently,
source to source compilation of JavaScript has become increasingly popular,
whether embedded HTML DSLs as with React JSX, or the new ECMAScript standards that
address many of JavaScript's old weaknesses. But integrating these new kinds of
source files required deferring to JavaScript build tools which still lack
the more advanced features of the Google Closure compiler like precise dead code
elimination and code splitting.

Fortunately, Google Closure has not only kept abreast of many of the various
enhancements to the JavaScript language, they've also provided transformation
from the various popular JavaScript module formats (CommonJS, AMD, ES6) into the
Google Closure namespace convention. ClojureScript now exposes all of this
functionality and, with the help of Java 8's Nashorn JavaScript engine, can
provide even the most cutting edge JavaScript source transforms with
relative ease.

[[prerequisites]]
== Prerequisites

This guide assumes you have the latest release of JDK 8 and the latest stable
version of Node.js installed for the REPL portion of the guide. This guide only
uses Leiningen for managing dependencies and is easily adapted to Boot or Maven.

[[es6]]
== ES6

First let's see how ES6 source files can be a part of your build:

----
mkdir -p hello-es6
cd hello-es6
touch project.clj
----

Edit the `project.clj` file to look like the following:

[source,clojure]
----
(defproject hello-es6 "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.9.0-alpha13"]
                 [org.clojure/clojurescript "1.9.NNN"]]
  :jvm-opts ^:replace ["-Xmx1g" "-server"])
----

Create a watch script:

----
touch watch.clj
----

Edit it to look like the following:

[source,clojure]
----
(require '[cljs.build.api :as b])

(b/watch "src"
  {:output-to    "out/main.js"
   :output-dir   "out"
   :main         'hello-es6.core
   :target       :nodejs
   :foreign-libs [{:file "src"
                   :module-type :es6}
   :verbose      true])
----

Notice that a `:foreign-libs` entry may now specify a directory for `:file`.
In this case the ClojureScript compiler will recursive search this directory
for `.js` files and automatically create the `:foreign-libs` entries for you
with the supplied options. The `:provides` namespace for each entry will
automatically be created from the the directory structure.

Let's create the main ClojureScript namespace:

----
mkdir -p src/hello_es6
touch src/hello_es6/core.cljs
----

Edit this file to look like the following:

[source,clojure]
----
(ns hello-es6.core
  (:require [cljs.nodejs :as nodejs]
            [js.hello :as hello]))

(nodejs/enable-util-print!)

(defn -main [& args]
  (hello/sayHello))

(set! *main-cli-fn* -main)
----

Note that our JavaScript file can imported like any other Google Closure
namespace.

Let's write the JavaScript:

----
mkdir -p src/js/hello.js
----

JavaScript files do not declare namespaces, so we compute one based on the
location of entry. Since the `:foreign-libs` entry specified `"src"` the
namespace of this JavaScript file for usage from ClojureScript will be `js.hello`.

Edit this file to look like the following:

[source,javascript]
----
export let sayHello = function() {
    console.log("Hello, world!");
};
----

Let's check that our watch script works:

----
lein trampoline run -m clojure.main watch.clj
----

You can verify the script works as intended by invoking Node on `out/main.js`:

----
node out/main.js
Hello world!
----

[[REPL]]
== REPL

[[Babel]]
== Babel

Download `babel.min.js` into your project directory:

----
curl -O https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.18.1/babel.min.js
----

Change your `watch.clj` to look like the following:

[source,clojure]
----
(require '[clojure.java.io :as io])
(require '[cljs.build.api :as b])
(require '[cljs.closure :as closure])
(import 'javax.script.ScriptEngineManager)

;; Create a shared Nashorn instance and eval Babel
(def engine
  (doto (.getEngineByName (ScriptEngineManager.) "nashorn")
    (.eval (io/reader (io/file "babel.min.js")))))

;; Add a custom transform
(defmethod closure/js-transforms :jsx [ijs opts]
  (let [code (str (gensym))]
    (.put engine code (:source ijs))
    (assoc ijs :source
      (.eval engine (str "Babel.transform("code", {presets: ['react', 'es2016']}).code")))))

(b/watch "src"
  {:output-to    "out/main.js"
   :output-dir   "out"
   :main         'hello-es6.core
   :target       :nodejs
   :foreign-libs [{:file "src"
                   :module-type :es6
                   :preprocess :jsx}
   :verbose      true])
----

First we create the Nashorn engine and evaluate the Babel script. To add custom
name preprocessers we simply add a `defmethod` case to
`cljs.closure/js-transforms`. Then in our `:foreign-libs` entry we can specify
`:preprocess` and use this named transform.