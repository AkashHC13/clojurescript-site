= JavaScript Modules (Alpha)
David Nolen
2017-01-22
:type: guides
:toc: macro
:icons: font

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

This page documents how to mix modern JavaScript source files seamlessly into
an existing ClojureScript project. The features documented should be considered
of alpha quality and subject to change.

[[motivation]]
== Motivation

When ClojureScript was initially released, compilation to JavaScript was still a
novelty and source transformation beyond minification was rare. Since then,
source to source compilation of JavaScript has become increasingly popular,
whether embedded HTML DSLs as with
https://facebook.github.io/react/docs/introducing-jsx.html[React JSX], or the
https://www.ecma-international.org/ecma-262/7.0/[new ECMAScript standards] that
address many of JavaScript's old weaknesses. But integrating these new kinds of
source files into a ClojureScript project required deferring to JavaScript build
tools which still lack the more advanced features of the Google Closure compiler
like precise dead code elimination and code splitting.

Fortunately, Google Closure has not only kept abreast of many of the various
enhancements to the JavaScript language, they've also provided transformation
from the various popular JavaScript module formats (CommonJS, AMD, ES6) into the
Google Closure namespace convention. ClojureScript now exposes all of this
functionality and, with the help of
http://openjdk.java.net/projects/nashorn/[Java 8's Nashorn JavaScript engine],
can provide even the most cutting edge JavaScript source transforms with
relative ease.

In addition Google Closure now has support for the Node.js resolution algorithm.
The ClojureScript compiler can now build projects that want to use dependencies
from NPM.

[[prerequisites]]
== Prerequisites

Like the link:quickstart.html[Quick Start], this guide assumes you have the
latest release of
https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[JDK
8], https://nodejs.org[Node.js >= 6.9.4] and https://clojure.org/guides/getting_started[Clojure] installed.

[[javascript-modules]]
== JavaScript Modules

First let's see how JavaScript modules can be a part of your build. We'll focus
on ES6, but the instructions are the same for CommonJS. First set up a project
folder for our program. Here’s a list of the files and folders you’ll need. Note
that the directory structure and the underscores in the names are important and
should not be changed.

[source,text]
----
hello-es6          # Our project folder
├─ src             # The CLJS source code for our project
│  └─ hello_es6    # Our hello_world namespace folder
│     └─ core.cljs # Our main file
└─ deps.edn        # A file for listing our dependencies
----

Edit the `deps.edn` file to look like the following:

[source,clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.238"}}}
----

Create a compiler options file:

----
touch build.edn
----

Edit it to look like the following:

[source,clojure]
----
{:main         hello-es6.core
 :output-to    "out/main.js"
 :output-dir   "out"
 :foreign-libs [{:file "src" :module-type :es6}] ;; or :commonjs
 :verbose      true})
----

Notice that a `:foreign-libs` entry can specify a directory for `:file`.
In this case, the ClojureScript compiler will recursively search this directory
for `.js` files and automatically create the `:foreign-libs` entries for you
with the supplied options. The `:provides` namespace for each entry will
be automatically computed from the directory structure.

Edit `src/hello_es6/core.cljs` to look like the following:

[source,clojure]
----
(ns hello-es6.core
  (:require [js.hello :as hello]))

(hello/sayHello)
----

Note that our JavaScript file can be imported like any other Google Closure
namespace.

Let's write the JavaScript. JavaScript files do not declare namespaces, so the
ClojureScript compiler will compute one based on the location of the entry.
Since the `:foreign-libs` entry specified `"src"`, the namespace of this
JavaScript file for usage from ClojureScript will be `js.hello`.

Edit `src/js/hello.js` to look like the following:

[source,javascript]
----
export var sayHello = function() {
    console.log("Hello, world!");
};
----

Let's compile our code and start a REPL:

----
clj -m cljs.main -co build.edn -c -r
----

When the browser loads you should see the following printed at the JavaScript
Console (not the REPL):

----
Hello world!
----

Without quitting your REPL, edit `src/js/hello.js` to the following:

[source,javascript]
----
export var sayHello = function() {
    console.log("Hello, world!");
};
export var sayThings = function(xs) { // ADDED
    for(let x of xs) {
        console.log(x);
    }
};
----

Reload your JavaScript module and try the new functionality:

----
cljs.user> (require '[js.hello :as hello] :reload)
true
cljs.user> (hello/sayThings ["ClojureScript", "+", "JavaScript", "Rocks!"])
nil
----

And in the JavaScript Console (not the REPL you will see:

----
ClojureScript
+
JavaScript
Rocks!
----

Since ClojureScript vectors support the ES6 iteration protocol
ES6 `for...of` just works.

While Google Closure can handle ES6 you may want to use other preprocessors from
the JavaScript ecosystem - for example http://babeljs.io[Babel's JSX transform].
In this case we will want to leverage Nashorn.

[[babel-transforms]]
== Babel Transforms

Change your `deps.edn` to the following:

[source,clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.238"}
        cljsjs/react {:mvn/version "15.4.2-0"}
        cljsjs/react-dom {:mvn/version "15.4.2-0"}
        cljsjs/react-dom-server {:mvn/version "15.4.2-0"}
        cljsjs/babel-standalone {:mvn/version "6.18.1-3"}}}
----

Change your `build.edn` to look like the following:

[source,clojure]
----
{:main         hello-es6.core
 :output-to    "out/main.js"
 :output-dir   "out"
 :foreign-libs [{:file "src" :module-type :es6
                 :preprocess cljsjs.babel-standalone/transform}] ;; CHANGED
 :verbose      true})
----

https://github.com/cljsjs/packages/tree/master/babel-standalone[Babel-standalone]
package from CLJSJS provides the necessary JavaScript file and a function that
can be used as `:preprocess` handler. The function uses Nashorn JS engine to run
Babel and process foreign libraries. Options to Babel can be provided by adding
property `:cljsjs.babel-standalone/babel-opts` to the foreign library map.

Let's add a React JSX component to `src/js/hello.js`:

[source,javascript]
----
export var sayHello = function() {
    console.log("Hello, world!");
};
export var sayThings = function(xs) {
    for(let x of xs) {
        console.log(x);
    }
};
export var reactHello = function() {
    return <div>Hello world!</div>
};
----

Let's change our ClojureScript:

[source,clojure]
----
(ns hello-es6.core
  (:require [cljsjs.react]
            [cljsjs.react.dom]
            [cljsjs.react.dom.server]
            [js.hello :as hello]))

(hello/sayHello)
(println (.renderToString js/ReactDOMServer (hello/reactHello)))
----

Build and run the REPL:

----
clj -m cljs.main -co build.edn -c -r
----

When the browser loads in the JavaScript Console (not the REPL), you should see
output like the following:

----
Hello, world!
<div data-reactroot="" data-reactid="1" data-react-checksum="1334186935">Hello world!</div>
----

You may have noticed that our ES6 file does not declare its dependency
on React, ReactDOM, or ReactDOMServer via `import`. Handling this correctly
depends on a pending patch to Google Closure to support Node.js module
resolution for ES6 source files. When this change lands this guide will updated.

However CommonJS support for Node.js resolution works today. The following
section covers this topic and will eventually apply to ES6 files as well.

[[custom-transforms]]
== Custom JavaScript transforms

In previous example the Babel transformation function was provided by a CLJSJS
package. If you need to use different transformations you can write your own
preprocessing function. The Babel transformation can be implemented like this,
without the CLJSJS package:

Remove `cljsjs/babel-standalone` dependency from your project.clj.

Download `babel.min.js` into your project directory:

----
curl -O https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.18.1/babel.min.js
----

Create a new `src/hello_es6/babel.clj` file:

[source,clojure]
----
(ns hello-es6.babel
  (:require [clojure.java.io :as io]
            [cljs.build.api :as b])
  (:import javax.script.ScriptEngineManager))

(def engine
  (doto (.getEngineByName (ScriptEngineManager.) "nashorn")
    (.eval (io/reader (io/file "babel.min.js")))))

(defn transform-jsx [js-module opts]
  (let [code (str (gensym))]
    (.put engine code (:source js-module))
    (assoc js-module :source
      (.eval engine (str "Babel.transform("code", {presets: ['react', 'es2016']}).code")))))
----

Change your `build.edn` to look like the following:

[source,clojure]
----
{:main         'hello-es6.core
 :output-to    "out/main.js"
 :output-dir   "out"
 :foreign-libs [{:file "src" :module-type :es6
                 :preprocess 'hello-es6.babel/transform-jsx}] ;; CHANGED
 :verbose      true})
----

[[node-modules]]
== Node Modules

ClojureScript now has support for building dependencies from NPM. Like
everything else in this guide this support should be considered experimental
and subject to change. Even when consuming dependencies from NPM all the usual
caveats around Google Closure Compiler apply. You may in some cases, as we will
see, need to supply externs for library internals in order to compile
successfully.

We will see how we can successfully compile React and ReactDOM server NPM
module packages.

First lets create a new project:

----
mkdir hello-cjs
cd hello-cjs
touch project.clj
touch package.json
----

Edit `deps.edn` to look like the following:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.238"}
        cljsjs/react {:mvn/version "15.4.2-0"}
        cljsjs/react-dom {:mvn/version "15.4.2-0"}
        cljsjs/react-dom-server {:mvn/version "15.4.2-0"}}}
----

Notice that we've declared a bunch of CLJSJS dependencies. We're not going to
actually use them, we're only pulling them in to get the externs.

Edit `package.json` to look like the following:

[source,javascript]
----
{
  "devDependencies": { // REMOVE
    "module-deps": "4.0.8",
    "resolve": "1.3.3",
    "browser-resolve": "1.11.2"
  },
  "dependencies": {
    "react": "15.4.2",
    "react-dom": "15.4.2"
  }
}
----

The ClojureScript compiler needs the `module-deps`, `resolve` and 
`browser-resolve` development time packages to build the project.

Install the deps:

----
npm install
----

Let's write a simple program. First the ClojureScript:

----
mkdir -p src/hello_cjs
touch src/hello_cjs/core.cljs
----

Edit `src/hello_cjs/core.cljs` to look like the following:

[source,clojures]
----
(ns hello-cjs.core
  (:require [libs.npm-stuff :as npm-stuff]))

(println (npm-stuff/renderSomething))
----

Now let's make a CommonJS file that will load deps from `node_modules`:

----
mkdir src/libs
touch src/libs/npm_stuff.js
----

Edit `src/libs/npm_stuff.js` to look like the following:

[source,javascript]
----
var React = require("react"); // change to ES6
var ReactDOMServer = require("react-dom/server");

function renderSomething() {
    return ReactDOMServer.renderToString(React.createElement("div", {}, "Hello world!"));
};

module.exports = {
    renderSomething: renderSomething
};
----

Now let's make our build file.

----
touch build.clj
----

Edit `build.clj` to look like the following:

[source,clojure]
----
(require '[clojure.java.io :as io]
         '[cljs.build.api :as b])

(b/build (b/inputs "src")
  {:main       'hello-cjs.core
   :target     :nodejs
   :output-to  "out/main.js"
   :output-dir "out"
   :verbose    true
   :externs    ["process.js"] // REMOVE
   :foreign-libs (let [entry {:file (.getAbsolutePath (io/file "src/libs/npm_stuff.js"))
                              :provides ["libs.npm-stuff"]
                              :module-type :commonjs}]
                   (into [entry] (b/node-inputs [entry]))) // necessary?
   :optimizations :advanced
   :closure-warnings {:non-standard-jsdoc :off :global-this :off}})

(System/exit 0)
----

Notice the new helper, `cljs.build.api/node-inputs`, which takes a sequence
of JavaScript entry points. The ClojureScript compiler will now invoke a Node.js
script to figure out all the `node_module` dependencies needed by these entry
points and return a vector of CommonJS foreign lib entries.

Also notice the presence of a extern file. To get `process.js`:

----
curl -O https://raw.githubusercontent.com/dcodeIO/node.js-closure-compiler-externs/master/process.js
----

We need these additional externs because internally React refers to the
`process` module. `:pseudo-names true` is a good way to figure out cases like
this. In the future hopefully these externs will be covered by CLJSJS.

We're now ready to build our project:

----
clj -m cljs.main -co build.edn -c -r
----

You might see a couple of warnings about the CommonJS files that can be ignored.
Once the compilation process is complete run `main.js`:

----
node main.js
----

You should see some server rendered HTML.
